# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T09:35:28+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query
from pydantic import constr

from models import (
    Account,
    AccountPatchRequest,
    ApiKey,
    ApiKeyIds,
    ApiKeys,
    ApikeysApiKeyPatchRequest,
    ApikeysModeImportFormatPostRequest,
    ApikeysPostRequest,
    Authorizer,
    Authorizers,
    BadRequestException,
    BasePathMapping,
    BasePathMappings,
    ClientCertificate,
    ClientCertificates,
    ClientcertificatesClientcertificateIdPatchRequest,
    ClientcertificatesPostRequest,
    ConflictException,
    Deployment,
    Deployments,
    DocumentationPart,
    DocumentationPartIds,
    DocumentationParts,
    DocumentationVersion,
    DocumentationVersions,
    DomainName,
    DomainNames,
    DomainnamesDomainNameBasepathmappingsBasePathPatchRequest,
    DomainnamesDomainNameBasepathmappingsPostRequest,
    DomainnamesDomainNamePatchRequest,
    DomainnamesPostRequest,
    Embed,
    ExportResponse,
    Format,
    GatewayResponse,
    GatewayResponses,
    Integration,
    IntegrationResponse,
    LimitExceededException,
    LocationStatus,
    Method,
    MethodResponse,
    Mode,
    Mode4,
    Model,
    Models,
    NotFoundException,
    Parameters,
    RequestValidator,
    RequestValidators,
    Resource,
    Resources,
    ResponseType,
    RestApi,
    RestApis,
    RestapisModeImportPostRequest,
    RestapisPostRequest,
    RestapisRestapiIdAuthorizersAuthorizerIdPatchRequest,
    RestapisRestapiIdAuthorizersAuthorizerIdPostRequest,
    RestapisRestapiIdAuthorizersPostRequest,
    RestapisRestapiIdDeploymentsDeploymentIdPatchRequest,
    RestapisRestapiIdDeploymentsPostRequest,
    RestapisRestapiIdDocumentationPartsPartIdPatchRequest,
    RestapisRestapiIdDocumentationPartsPostRequest,
    RestapisRestapiIdDocumentationPartsPutRequest,
    RestapisRestapiIdDocumentationVersionsDocVersionPatchRequest,
    RestapisRestapiIdDocumentationVersionsPostRequest,
    RestapisRestapiIdGatewayresponsesResponseTypePatchRequest,
    RestapisRestapiIdGatewayresponsesResponseTypePutRequest,
    RestapisRestapiIdModelsModelNamePatchRequest,
    RestapisRestapiIdModelsPostRequest,
    RestapisRestapiIdPatchRequest,
    RestapisRestapiIdPutRequest,
    RestapisRestapiIdRequestvalidatorsPostRequest,
    RestapisRestapiIdRequestvalidatorsRequestvalidatorIdPatchRequest,
    RestapisRestapiIdResourcesParentIdPostRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodIntegrationPatchRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodIntegrationPutRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodIntegrationResponsesStatusCodePatchRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodIntegrationResponsesStatusCodePutRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodPatchRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodPostRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodPutRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodResponsesStatusCodePatchRequest,
    RestapisRestapiIdResourcesResourceIdMethodsHttpMethodResponsesStatusCodePutRequest,
    RestapisRestapiIdResourcesResourceIdPatchRequest,
    RestapisRestapiIdStagesPostRequest,
    RestapisRestapiIdStagesStageNamePatchRequest,
    SdkResponse,
    SdkType,
    SdkTypes,
    ServiceUnavailableException,
    Stage,
    Stages,
    TagKeys,
    Tags,
    TagsResourceArnPutRequest,
    Template,
    TestInvokeAuthorizerResponse,
    TestInvokeMethodResponse,
    TooManyRequestsException,
    Type1,
    UnauthorizedException,
    Usage,
    UsagePlan,
    UsagePlanKey,
    UsagePlanKeys,
    UsagePlans,
    UsageplansPostRequest,
    UsageplansUsageplanIdKeysKeyIdUsagePatchRequest,
    UsageplansUsageplanIdKeysPostRequest,
    UsageplansUsageplanIdPatchRequest,
    VpcLink,
    VpcLinks,
    VpclinksPostRequest,
    VpclinksVpclinkIdPatchRequest,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='<fullname>Amazon API Gateway</fullname> <p>Amazon API Gateway helps developers deliver robust, secure, and scalable mobile and web application back ends. API Gateway allows developers to securely connect mobile and web applications to APIs that run on AWS Lambda, Amazon EC2, or other publicly addressable web services that are hosted outside of AWS.</p>',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='Amazon API Gateway',
    version='2015-07-09',
    servers=[
        {
            'description': 'The Amazon API Gateway multi-region endpoint',
            'url': 'http://apigateway.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Amazon API Gateway multi-region endpoint',
            'url': 'https://apigateway.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Amazon API Gateway endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://apigateway.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The Amazon API Gateway endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://apigateway.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/account',
    description=""" Gets information about the current Account resource. """,
    tags=[
        'rest_api_configuration',
        'integration_operations',
        'gateway_response_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_account(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/account',
    description=""" Changes information about the current Account resource. """,
    tags=['account_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_account(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: AccountPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apikeys',
    description=""" Gets information about the current ApiKeys resource. """,
    tags=[
        'account_operations',
        'api_key_operations',
        'client_certificate_operations',
        'domain_configuration',
        'base_path_mapping_operations',
        'rest_api_configuration',
        'authorizer_operations',
        'deployment_operations',
        'api_documentation_management',
        'gateway_response_operations',
        'model_operations',
        'request_validator_operations',
        'resource_operations',
        'http_method_configuration',
        'integration_operations',
        'integration_response_operations',
        'method_response_operations',
        'stage_operations',
        'sdk_operations',
        'resource_tagging',
        'usage_plan_operations',
        'vpc_link_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_api_keys(
    position: Optional[str] = None,
    limit: Optional[int] = None,
    name: Optional[str] = None,
    customer_id: Optional[str] = Query(None, alias='customerId'),
    include_values: Optional[bool] = Query(None, alias='includeValues'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apikeys',
    description=""" Create an ApiKey resource.  """,
    tags=['api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_api_key(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApikeysPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apikeys#mode=import&format',
    description=""" Import API keys from an external source, such as a CSV-formatted file. """,
    tags=['api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def import_api_keys(
    format: Format,
    failonwarnings: Optional[bool] = None,
    mode: Mode = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApikeysModeImportFormatPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apikeys/{api_Key}',
    description=""" Deletes the ApiKey resource. """,
    tags=['api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_api_key(
    api__key: str = Path(..., alias='api_Key'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apikeys/{api_Key}',
    description=""" Gets information about the current ApiKey resource. """,
    tags=['api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_api_key(
    api__key: str = Path(..., alias='api_Key'),
    include_value: Optional[bool] = Query(None, alias='includeValue'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/apikeys/{api_Key}',
    description=""" Changes information about an ApiKey resource. """,
    tags=['api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_api_key(
    api__key: str = Path(..., alias='api_Key'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ApikeysApiKeyPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/clientcertificates',
    description=""" Gets a collection of ClientCertificate resources. """,
    tags=['request_validator_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_client_certificates(
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/clientcertificates',
    description=""" Generates a ClientCertificate resource. """,
    tags=['client_certificate_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def generate_client_certificate(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ClientcertificatesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/clientcertificates/{clientcertificate_id}',
    description=""" Deletes the ClientCertificate resource. """,
    tags=['client_certificate_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_client_certificate(
    clientcertificate_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/clientcertificates/{clientcertificate_id}',
    description=""" Gets information about the current ClientCertificate resource. """,
    tags=['client_certificate_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_client_certificate(
    clientcertificate_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/clientcertificates/{clientcertificate_id}',
    description=""" Changes information about an ClientCertificate resource. """,
    tags=['client_certificate_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_client_certificate(
    clientcertificate_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: ClientcertificatesClientcertificateIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domainnames',
    description=""" Represents a collection of DomainName resources. """,
    tags=['integration_operations', 'gateway_response_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_domain_names(
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/domainnames',
    description=""" Creates a new domain name. """,
    tags=['domain_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_domain_name(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DomainnamesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/domainnames/{domain_name}',
    description=""" Deletes the DomainName resource. """,
    tags=['domain_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_domain_name(
    domain_name: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domainnames/{domain_name}',
    description=""" Represents a domain name that is contained in a simpler, more intuitive URL that can be called. """,
    tags=['domain_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_domain_name(
    domain_name: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/domainnames/{domain_name}',
    description=""" Changes information about the DomainName resource. """,
    tags=['domain_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_domain_name(
    domain_name: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DomainnamesDomainNamePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domainnames/{domain_name}/basepathmappings',
    description=""" Represents a collection of BasePathMapping resources. """,
    tags=['domain_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_base_path_mappings(
    domain_name: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/domainnames/{domain_name}/basepathmappings',
    description=""" Creates a new BasePathMapping resource. """,
    tags=['domain_configuration', 'base_path_mapping_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_base_path_mapping(
    domain_name: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DomainnamesDomainNameBasepathmappingsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/domainnames/{domain_name}/basepathmappings/{base_path}',
    description=""" Deletes the BasePathMapping resource. """,
    tags=['domain_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_base_path_mapping(
    domain_name: str,
    base_path: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/domainnames/{domain_name}/basepathmappings/{base_path}',
    description=""" Describe a BasePathMapping resource. """,
    tags=['domain_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_base_path_mapping(
    domain_name: str,
    base_path: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/domainnames/{domain_name}/basepathmappings/{base_path}',
    description=""" Changes information about the BasePathMapping resource. """,
    tags=['domain_configuration', 'base_path_mapping_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_base_path_mapping(
    domain_name: str,
    base_path: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: DomainnamesDomainNameBasepathmappingsBasePathPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis',
    description=""" Lists the RestApis resources for your collection. """,
    tags=['api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_rest_apis(
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis',
    description=""" Creates a new RestApi resource. """,
    tags=[
        'integration_operations',
        'http_method_configuration',
        'rest_api_configuration',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_rest_api(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis#mode=import',
    description=""" A feature of the API Gateway control service for creating a new API from an external API definition file. """,
    tags=['rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def import_rest_api(
    failonwarnings: Optional[bool] = None,
    parameters: Optional[Parameters] = None,
    mode: Mode = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisModeImportPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}',
    description=""" Deletes the specified API. """,
    tags=['rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_rest_api(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}',
    description=""" Lists the RestApi resource in the collection. """,
    tags=['rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_rest_api(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}',
    description=""" Changes information about the specified API. """,
    tags=['rest_api_configuration', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_rest_api(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/restapis/{restapi_id}',
    description=""" A feature of the API Gateway control service for updating an existing API with an input of external API definitions. The update can take the form of merging the supplied definition into the existing API or overwriting the existing API. """,
    tags=['rest_api_configuration', 'resource_operations', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_rest_api(
    restapi_id: str,
    mode: Optional[Mode4] = None,
    failonwarnings: Optional[bool] = None,
    parameters: Optional[Parameters] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/authorizers',
    description=""" Describe an existing Authorizers resource. """,
    tags=['rest_api_configuration', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_authorizers(
    restapi_id: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/authorizers',
    description=""" Adds a new Authorizer resource to an existing RestApi resource. """,
    tags=['authorizer_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_authorizer(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdAuthorizersPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/authorizers/{authorizer_id}',
    description=""" Deletes an existing Authorizer resource. """,
    tags=['authorizer_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_authorizer(
    restapi_id: str,
    authorizer_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/authorizers/{authorizer_id}',
    description=""" Describe an existing Authorizer resource. """,
    tags=['authorizer_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_authorizer(
    restapi_id: str,
    authorizer_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/authorizers/{authorizer_id}',
    description=""" Updates an existing Authorizer resource. """,
    tags=['authorizer_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_authorizer(
    restapi_id: str,
    authorizer_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdAuthorizersAuthorizerIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/authorizers/{authorizer_id}',
    description=""" Simulate the execution of an Authorizer in your RestApi with headers, parameters, and an incoming request body. """,
    tags=['authorizer_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def test_invoke_authorizer(
    restapi_id: str,
    authorizer_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdAuthorizersAuthorizerIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/deployments',
    description=""" Gets information about a Deployments collection. """,
    tags=['rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_deployments(
    restapi_id: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/deployments',
    description=""" Creates a Deployment resource, which makes a specified RestApi callable over the internet. """,
    tags=['deployment_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_deployment(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdDeploymentsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/deployments/{deployment_id}',
    description=""" Deletes a Deployment resource. Deleting a deployment will only succeed if there are no Stage resources associated with it. """,
    tags=['deployment_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_deployment(
    restapi_id: str,
    deployment_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/deployments/{deployment_id}',
    description=""" Gets information about a Deployment resource. """,
    tags=['deployment_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_deployment(
    restapi_id: str,
    deployment_id: str = ...,
    embed: Optional[Embed] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/deployments/{deployment_id}',
    description=""" Changes information about a Deployment resource. """,
    tags=['deployment_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_deployment(
    restapi_id: str,
    deployment_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdDeploymentsDeploymentIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/documentation/parts',
    description=""" Gets documentation parts. """,
    tags=['rest_api_configuration', 'api_key_operations', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_documentation_parts(
    restapi_id: str,
    type: Optional[Type1] = None,
    name: Optional[str] = None,
    path: Optional[str] = None,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    location_status: Optional[LocationStatus] = Query(None, alias='locationStatus'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/documentation/parts',
    description=""" Creates a documentation part. """,
    tags=['api_documentation_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_documentation_part(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdDocumentationPartsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/restapis/{restapi_id}/documentation/parts',
    description=""" Imports documentation parts """,
    tags=['api_documentation_management', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def import_documentation_parts(
    restapi_id: str,
    mode: Optional[Mode4] = None,
    failonwarnings: Optional[bool] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdDocumentationPartsPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/documentation/parts/{part_id}',
    description=""" Deletes a documentation part """,
    tags=[
        'rest_api_configuration',
        'integration_operations',
        'method_response_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_documentation_part(
    restapi_id: str,
    part_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/documentation/parts/{part_id}',
    description=""" Gets a documentation part. """,
    tags=['rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_documentation_part(
    restapi_id: str,
    part_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/documentation/parts/{part_id}',
    description=""" Updates a documentation part. """,
    tags=['api_documentation_management', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_documentation_part(
    restapi_id: str,
    part_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdDocumentationPartsPartIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/documentation/versions',
    description=""" Gets documentation versions. """,
    tags=[
        'rest_api_configuration',
        'integration_operations',
        'request_validator_operations',
        'http_method_configuration',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_documentation_versions(
    restapi_id: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/documentation/versions',
    description=""" Creates a documentation version """,
    tags=['api_documentation_management', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_documentation_version(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdDocumentationVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/documentation/versions/{doc_version}',
    description=""" Deletes a documentation version. """,
    tags=['rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_documentation_version(
    restapi_id: str,
    doc_version: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/documentation/versions/{doc_version}',
    description=""" Gets a documentation version. """,
    tags=[
        'rest_api_configuration',
        'api_documentation_management',
        'resource_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_documentation_version(
    restapi_id: str,
    doc_version: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/documentation/versions/{doc_version}',
    description=""" Updates a documentation version. """,
    tags=['api_documentation_management', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_documentation_version(
    restapi_id: str,
    doc_version: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdDocumentationVersionsDocVersionPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/gatewayresponses',
    description=""" Gets the GatewayResponses collection on the given RestApi. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default GatewayResponses collection for the supported response types. """,
    tags=['rest_api_configuration', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_gateway_responses(
    restapi_id: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/gatewayresponses/{response_type}',
    description=""" Clears any customization of a GatewayResponse of a specified response type on the given RestApi and resets it with the default settings. """,
    tags=['rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_gateway_response(
    restapi_id: str,
    response_type: ResponseType = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/gatewayresponses/{response_type}',
    description=""" Gets a GatewayResponse of a specified response type on the given RestApi. """,
    tags=[
        'rest_api_configuration',
        'integration_operations',
        'method_response_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_gateway_response(
    restapi_id: str,
    response_type: ResponseType = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/gatewayresponses/{response_type}',
    description=""" Updates a GatewayResponse of a specified response type on the given RestApi. """,
    tags=['gateway_response_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_gateway_response(
    restapi_id: str,
    response_type: ResponseType = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdGatewayresponsesResponseTypePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/restapis/{restapi_id}/gatewayresponses/{response_type}',
    description=""" Creates a customization of a GatewayResponse of a specified response type and status code on the given RestApi. """,
    tags=['gateway_response_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_gateway_response(
    restapi_id: str,
    response_type: ResponseType = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdGatewayresponsesResponseTypePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/models',
    description=""" Describes existing Models defined for a RestApi resource. """,
    tags=['rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_models(
    restapi_id: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/models',
    description=""" Adds a new Model resource to an existing RestApi resource. """,
    tags=['rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_model(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdModelsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/models/{model_name}',
    description=""" Deletes a model. """,
    tags=['rest_api_configuration', 'model_operations', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_model(
    restapi_id: str,
    model_name: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/models/{model_name}',
    description=""" Describes an existing model defined for a RestApi resource. """,
    tags=['model_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_model(
    restapi_id: str,
    model_name: str = ...,
    flatten: Optional[bool] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/models/{model_name}',
    description=""" Changes information about a model. """,
    tags=['model_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_model(
    restapi_id: str,
    model_name: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdModelsModelNamePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/models/{model_name}/default_template',
    description=""" Generates a sample mapping template that can be used to transform a payload into the structure of a model. """,
    tags=['model_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_model_template(
    restapi_id: str,
    model_name: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/requestvalidators',
    description=""" Gets the RequestValidators collection of a given RestApi. """,
    tags=['rest_api_configuration', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_request_validators(
    restapi_id: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/requestvalidators',
    description=""" Creates a RequestValidator of a given RestApi. """,
    tags=['request_validator_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_request_validator(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdRequestvalidatorsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}',
    description=""" Deletes a RequestValidator of a given RestApi. """,
    tags=['request_validator_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_request_validator(
    restapi_id: str,
    requestvalidator_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}',
    description=""" Gets a RequestValidator of a given RestApi. """,
    tags=['request_validator_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_request_validator(
    restapi_id: str,
    requestvalidator_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/requestvalidators/{requestvalidator_id}',
    description=""" Updates a RequestValidator of a given RestApi. """,
    tags=['request_validator_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_request_validator(
    restapi_id: str,
    requestvalidator_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdRequestvalidatorsRequestvalidatorIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/resources',
    description=""" Lists information about a collection of Resource resources. """,
    tags=[
        'rest_api_configuration',
        'resource_operations',
        'http_method_configuration',
        'integration_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_resources(
    restapi_id: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    embed: Optional[Embed] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/resources/{parent_id}',
    description=""" Creates a Resource resource. """,
    tags=['resource_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_resource(
    restapi_id: str,
    parent_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesParentIdPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/resources/{resource_id}',
    description=""" Deletes a Resource resource. """,
    tags=['rest_api_configuration', 'resource_operations', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_resource(
    restapi_id: str,
    resource_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/resources/{resource_id}',
    description=""" Lists information about a resource. """,
    tags=['resource_operations', 'rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_resource(
    restapi_id: str,
    resource_id: str = ...,
    embed: Optional[Embed] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/resources/{resource_id}',
    description=""" Changes information about a Resource resource. """,
    tags=['resource_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_resource(
    restapi_id: str,
    resource_id: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}',
    description=""" Deletes an existing Method resource. """,
    tags=['rest_api_configuration', 'resource_operations', 'http_method_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_method(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}',
    description=""" Describe an existing Method resource. """,
    tags=['resource_operations', 'http_method_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_method(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}',
    description=""" Updates an existing Method resource. """,
    tags=['http_method_configuration', 'resource_operations', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_method(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}',
    description=""" Simulate the invocation of a Method in your RestApi with headers, parameters, and an incoming request body. """,
    tags=[
        'http_method_configuration',
        'resource_operations',
        'integration_operations',
        'method_response_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def test_invoke_method(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}',
    description=""" Add a method to an existing Resource resource. """,
    tags=['http_method_configuration', 'resource_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_method(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration',
    description=""" Represents a delete integration. """,
    tags=['http_method_configuration', 'integration_operations', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_integration(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration',
    description=""" Get the integration settings. """,
    tags=['http_method_configuration', 'resource_operations', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_integration(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration',
    description=""" Represents an update integration. """,
    tags=['http_method_configuration', 'integration_operations', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_integration(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodIntegrationPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration',
    description=""" Sets up a method's integration. """,
    tags=['http_method_configuration', 'integration_operations', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_integration(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodIntegrationPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}',
    description=""" Represents a delete integration response. """,
    tags=['http_method_configuration', 'resource_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_integration_response(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    status_code: constr(pattern=r'[1-5]\d\d') = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}',
    description=""" Represents a get integration response. """,
    tags=['http_method_configuration', 'resource_operations', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_integration_response(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    status_code: constr(pattern=r'[1-5]\d\d') = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}',
    description=""" Represents an update integration response. """,
    tags=[
        'http_method_configuration',
        'integration_operations',
        'integration_response_operations',
        'resource_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_integration_response(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    status_code: constr(pattern=r'[1-5]\d\d') = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodIntegrationResponsesStatusCodePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/integration/responses/{status_code}',
    description=""" Represents a put integration. """,
    tags=[
        'integration_operations',
        'integration_response_operations',
        'http_method_configuration',
        'resource_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_integration_response(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    status_code: constr(pattern=r'[1-5]\d\d') = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodIntegrationResponsesStatusCodePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}',
    description=""" Deletes an existing MethodResponse resource. """,
    tags=['http_method_configuration', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_method_response(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    status_code: constr(pattern=r'[1-5]\d\d') = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}',
    description=""" Describes a MethodResponse resource. """,
    tags=['http_method_configuration', 'resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_method_response(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    status_code: constr(pattern=r'[1-5]\d\d') = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}',
    description=""" Updates an existing MethodResponse resource. """,
    tags=[
        'http_method_configuration',
        'resource_operations',
        'method_response_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_method_response(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    status_code: constr(pattern=r'[1-5]\d\d') = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodResponsesStatusCodePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/restapis/{restapi_id}/resources/{resource_id}/methods/{http_method}/responses/{status_code}',
    description=""" Adds a MethodResponse to an existing Method resource. """,
    tags=[
        'http_method_configuration',
        'resource_operations',
        'integration_operations',
        'method_response_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_method_response(
    restapi_id: str,
    resource_id: str = ...,
    http_method: str = ...,
    status_code: constr(pattern=r'[1-5]\d\d') = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdResourcesResourceIdMethodsHttpMethodResponsesStatusCodePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/stages',
    description=""" Gets information about one or more Stage resources. """,
    tags=['deployment_operations', 'rest_api_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_stages(
    restapi_id: str,
    deployment_id: Optional[str] = Query(None, alias='deploymentId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/restapis/{restapi_id}/stages',
    description=""" Creates a new Stage resource that references a pre-existing Deployment for the API.  """,
    tags=[
        'rest_api_configuration',
        'deployment_operations',
        'stage_operations',
        'integration_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_stage(
    restapi_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdStagesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/stages/{stage_name}',
    description=""" Deletes a Stage resource. """,
    tags=['rest_api_configuration', 'stage_operations', 'http_method_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_stage(
    restapi_id: str,
    stage_name: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/stages/{stage_name}',
    description=""" Gets information about a Stage resource. """,
    tags=['rest_api_configuration', 'stage_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_stage(
    restapi_id: str,
    stage_name: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/restapis/{restapi_id}/stages/{stage_name}',
    description=""" Changes information about a Stage resource. """,
    tags=['rest_api_configuration', 'stage_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_stage(
    restapi_id: str,
    stage_name: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: RestapisRestapiIdStagesStageNamePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/stages/{stage_name}/cache/authorizers',
    description=""" Flushes all authorizer cache entries on a stage. """,
    tags=['stage_operations', 'rest_api_configuration', 'integration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def flush_stage_authorizers_cache(
    restapi_id: str,
    stage_name: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/restapis/{restapi_id}/stages/{stage_name}/cache/data',
    description=""" Flushes a stage's cache. """,
    tags=[
        'rest_api_configuration',
        'deployement_operations',
        'http_method_configuration',
        'stage_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def flush_stage_cache(
    restapi_id: str,
    stage_name: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/stages/{stage_name}/exports/{export_type}',
    description=""" Exports a deployed version of a RestApi in a specified format. """,
    tags=['rest_api_configuration', 'stage_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_export(
    restapi_id: str,
    stage_name: str = ...,
    export_type: str = ...,
    parameters: Optional[Parameters] = None,
    accept: Optional[str] = Header(None, alias='Accept'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/restapis/{restapi_id}/stages/{stage_name}/sdks/{sdk_type}',
    description=""" Generates a client SDK for a RestApi and Stage. """,
    tags=['sdk_operations', 'rest_api_configuration', 'stage_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sdk(
    restapi_id: str,
    stage_name: str = ...,
    sdk_type: str = ...,
    parameters: Optional[Parameters] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sdktypes',
    description=""" Gets SDK types """,
    tags=['vpc_link_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sdk_types(
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sdktypes/{sdktype_id}',
    description=""" Gets an SDK type. """,
    tags=['sdk_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sdk_type(
    sdktype_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{resource_arn}',
    description=""" Gets the Tags collection for a given resource. """,
    tags=['resource_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_tags(
    resource_arn: str,
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/tags/{resource_arn}',
    description=""" Adds or updates a tag on a given resource. """,
    tags=['resource_operations', 'resource_tagging'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagsResourceArnPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{resource_arn}#tagKeys',
    description=""" Removes a tag from a given resource. """,
    tags=['resource_tagging'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: str,
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/usageplans',
    description=""" Gets all the usage plans of the caller's account. """,
    tags=['api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_usage_plans(
    position: Optional[str] = None,
    key_id: Optional[str] = Query(None, alias='keyId'),
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/usageplans',
    description=""" Creates a usage plan with the throttle and quota limits, as well as the associated API stages, specified in the payload.  """,
    tags=['usage_plan_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_usage_plan(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UsageplansPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/usageplans/{usageplanId}',
    description=""" Deletes a usage plan of a given plan Id. """,
    tags=['usage_plan_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_usage_plan(
    usageplan_id: str = Path(..., alias='usageplanId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/usageplans/{usageplanId}',
    description=""" Gets a usage plan of a given plan identifier. """,
    tags=['usage_plan_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_usage_plan(
    usageplan_id: str = Path(..., alias='usageplanId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/usageplans/{usageplanId}',
    description=""" Updates a usage plan of a given plan Id. """,
    tags=['usage_plan_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_usage_plan(
    usageplan_id: str = Path(..., alias='usageplanId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UsageplansUsageplanIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/usageplans/{usageplanId}/keys',
    description=""" Gets all the usage plan keys representing the API keys added to a specified usage plan. """,
    tags=['usage_plan_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_usage_plan_keys(
    usageplan_id: str = Path(..., alias='usageplanId'),
    position: Optional[str] = None,
    limit: Optional[int] = None,
    name: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/usageplans/{usageplanId}/keys',
    description=""" Creates a usage plan key for adding an existing API key to a usage plan. """,
    tags=['usage_plan_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_usage_plan_key(
    usageplan_id: str = Path(..., alias='usageplanId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UsageplansUsageplanIdKeysPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/usageplans/{usageplanId}/keys/{keyId}',
    description=""" Deletes a usage plan key and remove the underlying API key from the associated usage plan. """,
    tags=['usage_plan_operations', 'api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_usage_plan_key(
    usageplan_id: str = Path(..., alias='usageplanId'),
    key_id: str = Path(..., alias='keyId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/usageplans/{usageplanId}/keys/{keyId}',
    description=""" Gets a usage plan key of a given key identifier. """,
    tags=['usage_plan_operations', 'api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_usage_plan_key(
    usageplan_id: str = Path(..., alias='usageplanId'),
    key_id: str = Path(..., alias='keyId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/usageplans/{usageplanId}/keys/{keyId}/usage',
    description=""" Grants a temporary extension to the remaining quota of a usage plan associated with a specified API key. """,
    tags=['usage_plan_operations', 'api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_usage(
    usageplan_id: str = Path(..., alias='usageplanId'),
    key_id: str = Path(..., alias='keyId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: UsageplansUsageplanIdKeysKeyIdUsagePatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/usageplans/{usageplanId}/usage#startDate&endDate',
    description=""" Gets the usage data of a usage plan in a specified time interval. """,
    tags=['usage_plan_operations', 'api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_usage(
    usageplan_id: str = Path(..., alias='usageplanId'),
    key_id: Optional[str] = Query(None, alias='keyId'),
    start_date: str = Query(..., alias='startDate'),
    end_date: str = Query(..., alias='endDate'),
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/vpclinks',
    description=""" Gets the VpcLinks collection under the caller's account in a selected region. """,
    tags=['api_key_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_vpc_links(
    position: Optional[str] = None,
    limit: Optional[int] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/vpclinks',
    description=""" Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services. """,
    tags=['vpc_link_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_vpc_link(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: VpclinksPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/vpclinks/{vpclink_id}',
    description=""" Deletes an existing VpcLink of a specified identifier. """,
    tags=['vpc_link_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_vpc_link(
    vpclink_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/vpclinks/{vpclink_id}',
    description=""" Gets a specified VPC link under the caller's account in a region. """,
    tags=['vpc_link_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_vpc_link(
    vpclink_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/vpclinks/{vpclink_id}',
    description=""" Updates an existing VpcLink of a specified identifier. """,
    tags=['vpc_link_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_vpc_link(
    vpclink_id: str,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: VpclinksVpclinkIdPatchRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
